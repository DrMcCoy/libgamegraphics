/**
 * @file   test-img.hpp
 * @brief  Generic image conversion test code.
 *
 * Copyright (C) 2010 Adam Nielsen <malvineous@shikadi.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <boost/test/unit_test.hpp>
#include <boost/bind.hpp>
#include <camoto/gamegraphics.hpp>
#include <iostream>
#include <sstream>

#include "tests.hpp"

using namespace camoto;
using namespace camoto::gamegraphics;

const uint8_t stdformat_test_image_8x8[] = {
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0A
};
const uint8_t stdformat_test_mask_8x8[] = {
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
};

const uint8_t stdformat_test_image_16x16[] = {
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,  0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0A
};

const uint8_t stdformat_test_mask_16x16[] = {
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
};

const uint8_t stdformat_test_image_9x9[] = {
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
	0x0C, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0A
};
const uint8_t stdformat_test_mask_9x9[] = {
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
};

// Defines to allow code reuse
#define COMBINE_CLASSNAME_EXP(c, n)  c ## _ ## n
#define COMBINE_CLASSNAME(c, n)  COMBINE_CLASSNAME_EXP(c, n)

#define TEST_VAR(n)        COMBINE_CLASSNAME(IMG_CLASS, n)
#define TEST_NAME(n)       TEST_VAR(n)
#define TEST_RESULT(n)     testdata_ ## n

#define FIXTURE_NAME       TEST_VAR(sample)
#define EMPTY_FIXTURE_NAME TEST_VAR(sample_empty)
#define SUITE_NAME         TEST_VAR(suite)
#define EMPTY_SUITE_NAME   TEST_VAR(suite_empty)
#define INITIALSTATE_NAME  TEST_RESULT(initialstate)

// Allow a string constant to be passed around with embedded nulls
#define makeString(x)  std::string((x), sizeof((x)) - 1)

struct FIXTURE_NAME: public default_sample {

	typedef boost::shared_ptr<std::stringstream> sstr_ptr;

	sstr_ptr baseData;
	camoto::iostream_sptr baseStream;
	FN_TRUNCATE fnTruncate;

	FIXTURE_NAME() :
		baseData(new std::stringstream),
		baseStream(this->baseData)
	{
		std::stringstream *pss = new std::stringstream;
		iostream_sptr ss(pss);
		this->fnTruncate = boost::bind<void>(stringStreamTruncate, pss, _1);
	}

};

BOOST_FIXTURE_TEST_SUITE(SUITE_NAME, FIXTURE_NAME)

BOOST_AUTO_TEST_CASE(TEST_NAME(to_standard_8x8))
{
	BOOST_TEST_MESSAGE("Converting to stdformat 8x8");

	baseData->str(makeString(TESTDATA_INITIAL_8x8));

	// Leaving fnTruncate as NULL here because it should not be required.
	ImagePtr conv = TEST_VAR(get_converter)(baseStream, NULL, 8, 8);
	StdImageDataPtr output = conv->toStandard();

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			stdformat_test_image_8x8,
			output.get(),
			8 * 8,
			8
		),
		"Error converting 8x8 image to standard format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_standard_16x16))
{
	BOOST_TEST_MESSAGE("Converting to stdformat 16x16");

	baseData->str(makeString(TESTDATA_INITIAL_16x16));

	// Leaving fnTruncate as NULL here because it should not be required.
	ImagePtr conv = TEST_VAR(get_converter)(baseStream, NULL, 16, 16);
	StdImageDataPtr output = conv->toStandard();

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			stdformat_test_image_16x16,
			output.get(),
			16 * 16,
			16
		),
		"Error converting 16x16 image to standard format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_standard_9x9))
{
	BOOST_TEST_MESSAGE("Converting to stdformat 9x9");

	baseData->str(makeString(TESTDATA_INITIAL_9x9));

	// Leaving fnTruncate as NULL here because it should not be required.
	ImagePtr conv = TEST_VAR(get_converter)(baseStream, NULL, 9, 9);
	StdImageDataPtr output = conv->toStandard();

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			stdformat_test_image_9x9,
			output.get(),
			9 * 9,
			9
		),
		"Error converting 9x9 image to standard format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_mask_8x8))
{
	BOOST_TEST_MESSAGE("Converting to stdmask 8x8");

	baseData->str(makeString(TESTDATA_INITIAL_8x8));

	// Leaving fnTruncate as NULL here because it should not be required.
	ImagePtr conv = TEST_VAR(get_converter)(baseStream, NULL, 8, 8);
	StdImageDataPtr output = conv->toStandardMask();

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			stdformat_test_mask_8x8,
			output.get(),
			8 * 8,
			8
		),
		"Error converting 8x8 image to standard mask format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_mask_16x16))
{
	BOOST_TEST_MESSAGE("Converting to stdmask 16x16");

	baseData->str(makeString(TESTDATA_INITIAL_16x16));

	// Leaving fnTruncate as NULL here because it should not be required.
	ImagePtr conv = TEST_VAR(get_converter)(baseStream, NULL, 16, 16);
	StdImageDataPtr output = conv->toStandardMask();

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			stdformat_test_mask_16x16,
			output.get(),
			16 * 16,
			16
		),
		"Error converting 16x16 image to standard mask format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_mask_9x9))
{
	BOOST_TEST_MESSAGE("Converting to stdmask 9x9");

	baseData->str(makeString(TESTDATA_INITIAL_9x9));

	// Leaving fnTruncate as NULL here because it should not be required.
	ImagePtr conv = TEST_VAR(get_converter)(baseStream, NULL, 9, 9);
	StdImageDataPtr output = conv->toStandardMask();

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			stdformat_test_mask_9x9,
			output.get(),
			9 * 9,
			9
		),
		"Error converting 9x9 image to standard mask format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_custom_8x8))
{
	BOOST_TEST_MESSAGE("Converting to custom format 8x8");

	StdImageDataPtr stddata(new uint8_t[8*8]);
	memcpy(stddata.get(), stdformat_test_image_8x8, 8*8);

	StdImageDataPtr stdmask(new uint8_t[8*8]);
	memcpy(stdmask.get(), stdformat_test_mask_8x8, 8*8);

	ImagePtr conv = TEST_VAR(get_converter)(baseStream, fnTruncate, 8, 8);
	conv->fromStandard(stddata, stdmask);

	// Make sure the right amount of data was written out
	BOOST_REQUIRE_EQUAL(baseData->str().length(), 1*8*5); // TODO: abstract plane count

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			(const uint8_t *)TESTDATA_INITIAL_8x8,
			(const uint8_t *)(baseData->str().c_str()),
			1*8*5, // TODO: abstract plane count
			1  *5
		),
		"Error converting 8x8 image to custom format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_custom_16x16))
{
	BOOST_TEST_MESSAGE("Converting to custom format 16x16");

	StdImageDataPtr stddata(new uint8_t[16*16]);
	memcpy(stddata.get(), stdformat_test_image_16x16, 16*16);

	StdImageDataPtr stdmask(new uint8_t[16*16]);
	memcpy(stdmask.get(), stdformat_test_mask_16x16, 16*16);

	ImagePtr conv = TEST_VAR(get_converter)(baseStream, fnTruncate, 16, 16);
	conv->fromStandard(stddata, stdmask);

	// Make sure the right amount of data was written out
	BOOST_REQUIRE_EQUAL(baseData->str().length(), 2*16*5); // TODO: abstract plane count

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			(const uint8_t *)TESTDATA_INITIAL_16x16,
			(const uint8_t *)(baseData->str().c_str()),
			2*16*5, // TODO: abstract plane count
			2   *5
		),
		"Error converting 16x16 image to custom format"
	);
}

BOOST_AUTO_TEST_CASE(TEST_NAME(to_custom_9x9))
{
	BOOST_TEST_MESSAGE("Converting to custom format 9x9");

	StdImageDataPtr stddata(new uint8_t[9*9]);
	memcpy(stddata.get(), stdformat_test_image_9x9, 9*9);

	StdImageDataPtr stdmask(new uint8_t[9*9]);
	memcpy(stdmask.get(), stdformat_test_mask_9x9, 9*9);

	ImagePtr conv = TEST_VAR(get_converter)(baseStream, fnTruncate, 9, 9);
	conv->fromStandard(stddata, stdmask);

	// Make sure the right amount of data was written out
	BOOST_REQUIRE_EQUAL(baseData->str().length(), 2*9*5); // TODO: abstract plane count

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(
			(const uint8_t *)TESTDATA_INITIAL_9x9,
			(const uint8_t *)(baseData->str().c_str()),
			2*9*5, // TODO: abstract plane count
			2  *5
		),
		"Error converting 9x9 image to custom format"
	);
}

BOOST_AUTO_TEST_SUITE_END()
