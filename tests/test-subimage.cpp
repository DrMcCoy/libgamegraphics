/**
 * @file   test-subimage.cpp
 * @brief  Test code for SubImage class.
 *
 * Copyright (C) 2010-2011 Adam Nielsen <malvineous@shikadi.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <boost/test/unit_test.hpp>
#include <boost/bind.hpp>
#include <camoto/gamegraphics/image.hpp>
#include <camoto/util.hpp>
#include <camoto/stream_string.hpp>
#include "../src/img-ega-byteplanar.hpp"
#include "../src/subimage.hpp"
#include "tests.hpp"

using namespace camoto::gamegraphics;
using namespace camoto;

#define TESTDATA_INITIAL \
	"\xFF\xFF\xFF\xFF\xFF" "\xFF\xFF\xFF\xFF\xFF" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\x80\x00\x00\x80\x80" "\x01\x00\x01\x00\x01" \
	"\xFF\x7F\x00\x80\xFF" "\xFF\xFE\x01\x00\xFF"

struct subimage: public default_sample {

	std::string d;
	stream::string_sptr base;
	ImagePtr img;
	SuppData suppData;

	subimage() :
		base(new stream::string())
	{
		this->d = makeString(TESTDATA_INITIAL);
		this->base->open(&this->d);
	}

	void openImage(int width, int height)
	{
		PLANE_LAYOUT planes;
		planes[PLANE_BLUE] = 2;
		planes[PLANE_GREEN] = 3;
		planes[PLANE_RED] = 4;
		planes[PLANE_INTENSITY] = 5;
		planes[PLANE_HITMAP] = 0;
		planes[PLANE_OPACITY] = -1;
		EGABytePlanarImage *ega = new EGABytePlanarImage();
		this->img.reset(ega);
		ega->setParams(this->base, 0, width, height, planes);
		BOOST_REQUIRE_MESSAGE(this->img, "Could not open image instance");
	}

};

BOOST_FIXTURE_TEST_SUITE(subimage_suite, subimage)

BOOST_AUTO_TEST_CASE(subimage_open)
{
	BOOST_TEST_MESSAGE("Opening subimage");

	this->openImage(16, 16);

	int subWidth = 4, subHeight = 2;

	ImagePtr sub(new SubImage(this->img, 0, 4, subWidth, subHeight));
	BOOST_REQUIRE_MESSAGE(sub, "Could not create sub image");

	StdImageDataPtr output = sub->toStandard();

	const uint8_t target[] = {
		0x0c, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00
	};

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(target, output.get(), subWidth * subHeight, subWidth),
		"Wrong data when opening subimage"
	);
}

BOOST_AUTO_TEST_CASE(subimage_open2)
{
	BOOST_TEST_MESSAGE("Opening subimage 2");

	this->openImage(16, 16);

	int subWidth = 4, subHeight = 2;

	ImagePtr sub(new SubImage(this->img, 16-subWidth, 16-subHeight, subWidth, subHeight));
	BOOST_REQUIRE_MESSAGE(sub, "Could not create sub image");

	StdImageDataPtr output = sub->toStandard();

	const uint8_t target[] = {
		0x00, 0x00, 0x00, 0x0a,
		0x09, 0x09, 0x09, 0x0a
	};

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(target, output.get(), subWidth * subHeight, subWidth),
		"Wrong data when opening subimage"
	);
}

BOOST_AUTO_TEST_CASE(subimage_open_mask)
{
	BOOST_TEST_MESSAGE("Opening subimage mask");

	this->openImage(16, 16);

	int subWidth = 4, subHeight = 2;

	ImagePtr sub(new SubImage(this->img, 16-subWidth, 16-subHeight, subWidth, subHeight));
	BOOST_REQUIRE_MESSAGE(sub, "Could not create sub image");

	StdImageDataPtr output = sub->toStandardMask();

	const uint8_t target[] = {
		0x01, 0x01, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00
	};

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(target, output.get(), subWidth * subHeight, subWidth),
		"Wrong data when opening subimage"
	);
}

BOOST_AUTO_TEST_CASE(subimage_edit)
{
	BOOST_TEST_MESSAGE("Editing subimage");

	this->openImage(16, 16);

	int subWidth = 4, subHeight = 2;

	ImagePtr sub(new SubImage(this->img, 16-subWidth, 16-subHeight, subWidth, subHeight));
	BOOST_REQUIRE_MESSAGE(sub, "Could not create sub image");

	const uint8_t change[] = {
		0x01, 0x02, 0x03, 0x04,
		0x08, 0x07, 0x06, 0x05,
	};
	const uint8_t changeMask[] = {
		0x01, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x01,
	};
	StdImageDataPtr alt(new uint8_t[subWidth * subHeight]);
	memcpy(alt.get(), change, subWidth * subHeight);
	StdImageDataPtr altMask(new uint8_t[subWidth * subHeight]);
	memcpy(altMask.get(), changeMask, subWidth * subHeight);
	sub->fromStandard(alt, altMask);

	StdImageDataPtr output = this->img->toStandard();
	const uint8_t target[] = {
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
		0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
		0x0C, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,  0x09, 0x09, 0x09, 0x09, 0x08, 0x07, 0x06, 0x05
	};

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(target, output.get(), 16 * 16, 16),
		"Wrong image data after editing subimage"
	);

	output = this->img->toStandardMask();
	const uint8_t targetMask[] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	};

	BOOST_CHECK_MESSAGE(
		default_sample::is_equal(targetMask, output.get(), 16 * 16, 16),
		"Wrong mask data after editing subimage"
	);
}

BOOST_AUTO_TEST_SUITE_END()
